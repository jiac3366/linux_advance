---
title: CPU上下文切换（上）
categories:
  - Linux性能优化
toc: true 
---

- 操作系统管理的“任务”有哪些？
  - 进程和线程
  - 硬件触发信号
- 系统负载升高因素之一：上下文切换频繁，缩短进程真正运行的时间
- 开销排名：进程上线文切换>同进程线程上线文切换>中断上线文切换>内核模式切换>协程上线文切换>用户态函数调用上下文切换
- 根据“任务”不同，上下文切换也就有不同的场景
  - 进程上下文切换
    - 进程既可以在用户空间运行，又可以在内核空间中运行。
    - 和系统调用（特权模式切换）的区别：
      - 1、进程上下文切换，是指从一个进程切换到另一个进程运行，而系统调用过程中一直是同一个进程在运行。
      - 2、切换的资源
        - 系统调用的过程发生了 2次CPU 上下文切换。每次切换**CPU寄存器**和**内核状态**（内核资源）。
          第一次：CPU 寄存器先保存原来用户态的指令位置，为了执行内核态代码， 需要更新为内核态指令的新位置。最后跳转到内核态运行内核任务。第二次同理。
        - 进程上下文切换不仅切换CPU寄存器和内核状态，还需要切换**虚拟内存、用户栈、全局变量**（用户资源），当虚拟内存刷新后，**TLB**（负责从虚拟地址转换到物理地址）也要刷新。
    - 什么时候会切换进程上下文？调度算法学一波！！
      - 进程时间片耗尽
      - 进程需要的内存（系统资源）不满足-->被挂起
      - 主动sleep -->被挂起
      - 更高优先级的来了-->被挂起
      - 硬件中断发生-->被挂起
  - 线程上下文切换
    - 线程上下文分2种
      - 前后的线程不属于同一个进程-->等同进程切换
      - 前后的线程属于同一个进程-->只切换线程的栈、寄存器等不共享的资源
  - 中断上下文切换
    - 中断上下文只包括内核态中断处理程序执行所必需的状态（**只发生在内核态**），包括 CPU 寄存器、 内核堆栈、硬件中断参数等，并不涉及到进程的用户态，所以即便硬件中断打断了进程的执行，也不用保存和恢复这个进程的虚拟内存、全局变量等用户态资源.

